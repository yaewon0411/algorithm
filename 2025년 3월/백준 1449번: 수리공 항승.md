## 문제
항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.

파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.

항승이는 길이가 L인 테이프를 무한개 가지고 있다.

항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.

물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.

## 입력
첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.

## 출력
첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.

## 예제 입력 1 
```
4 2
1 2 100 101
```
## 예제 출력 1 
```
2
```

## 풀이
테이프를 하나 붙일 때 좌우 0.5 간격을 두어야 하기 때문에 테이프 하나로 커버 가능한 구간은 [i-0.5, i+L-0.5]가 된다

최소한의 테이프 개수로 모든 누수 위치를 커버하기 위해 우선 오름차순으로 정렬한 후 왼쪽 구간부터 확인한다

커버 가능한 구간인지를 순차적으로 확인해서, 커버가 가능하지 않으면 그 구간부터 새 테이프를 붙인다

다시 가능한 범위 내 위치가 들어오는지를 입력 요소 끝까지 탐색하며 확인한다

예제의 경우 
```
L=2
1 2 100 101
```
첫 번째 누수 위치에서 커버 가능한 구간은 [0.5, 2.5]가 되니까 그 다음 위치인 2까지는 커버 가능하고,

그 다음 위치 100에서는 이 구간을 넘어서므로 다시 100에서 시작하는 커버 가능한 구간을 구하고 [99.5, 101.5], 이 안에 그 다음 위치인 101이 들어오니까

총 사용되는 최소 개수가 2개가 된다


```C++

#include <iostream>
#include <vector>
#include <algorithm>

#define fastio cin.tie(0), cout.tie(0), ios::sync_with_stdio(0)

using namespace std;


int main() {

	fastio;

	int N, L;
	cin >> N >> L;

	vector<int> v(N);
	for (int i = 0; i < N; i++) {
		cin >> v[i];
	}

	sort(begin(v), end(v));

	int cnt = 0;
	double covered = 0;

	for (int i = 0; i < N; i++) {
		if (v[i] > covered) {
			covered = v[i] + L - 0.5;
			cnt++;
		}
	}

	cout << cnt;

	return 0;
}
```







